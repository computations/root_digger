\documentclass{article}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{graphicx}

\title{Root Digger: a root placement program for phylogenetic trees}
\author{Ben Bettisworth, Alexandros Stamatakis}
\date{\today}

\begin{document}
\begin{abstract}
In phylogenetic analysis, it is common to infer trees which are unrooted. This
is to say, it is unknown which node is the most recent common ancestor of all
the taxa present in the phylogenetic tree. This information is often desirable,
as it provides a direction to the edges in the tree.  There exist several
methods to recover a root, including midpoint rooting and using a special taxon
as a so called outgroup. Additionally, a non-reversable Markov model can be used
to compute the likelihood of a root. In this paper, we present software which
uses a provided non-reversable model to compute the most likely root location.
\end{abstract}

\maketitle

% Main Points:
% - Rerunning analysis with outgroups is expensive, and can introduce errors
% - Midpoint rooting is a joke
% - This is fast and accurate.


\section{Introduction}

% Outline:
% - What is rooting
% - Why do we need it
% - Existing methods
% - What this method is
% - Why should we use this method

In phylogenetic analysis, it is common to infer unrooted trees. This is due in
part to the simplicity of the models, and the computational savings that come
from working with unrooted trees. But a having a root on a phylogenetic tree is
a desirable thing to have. Many phylogenetic studies root the tree after
inferring an unrooted tree.

There are several methods to root an existing phylogenetic tree, which fall into
one of three categories: methods which use "side-band" information; methods
which utilize some variation of the molecular clock hypothesis; and methods
which use a non-reversable model.

Methods that use "side-band" information take advantage of prior knowledge about
the world, which isn't present in the data that is used to infer a tree. For
example, knowledge about which species are distantly related can be used to add
an outgroup to phylogenetic analysis. This outgroup can then be used to place
the root on the tree.

There are challenges to adding  an  outgroup  to  an  analysis.   Gatsey  et.al.
\cite{gatesy_how_2007} showed that adding a  single  taxa  to  an  analysis  can
significantly impact the stability of the tree topology, even for the taxa which
were already present  in  the  analysis.   Holland  \cite{holland_outgroup_2003}
investigates this phenomenon in simulations, and that  outgroups  effecting  the
topology of ingroups can be uncomfortably common.

Alternativly, molecular clock analysis can be used to place a root without prior
knowledge\cite{yang_computational_2006}. The molecular clock hypothesis says
that base substitution "ticks" at stochastically constant rate. Using this
assumption, or some variant, a likely root can be placed on the root.

Molecular clock analysis can also have difficulties. In particular, the clock
does not "tick" at a constant rate all over the tree as shown in
\cite{steiper_primate_2006} and \cite{li_molecular_1987}. Relaxed clock models
exist which can help with this problem, but are not always successful
\cite{battistuzzi_performance_2010}.

The final method that can place a root on a tree is to perform the phylogenetic
analysis using a non reversable model. By using a reversable model, we can place
a direction of time for the branches on a tree \cite{yap_rooting_2005}.Several
software packages are able to infer a phylogenetic tree under an unreversable
model, thereby inferring a root \cite{nguyen_iq-tree:_2015}
\cite{ronquist_mrbayes_2003}. Unfortunatly, these packages are not capible of
taking an existing tree, and placing a root via a non-reversable model. This is
the method we use in Root Digger to infer a root.

\section{Methods}

To begin with, some definitions: A \textit{graph} is a collection of objects
(\textit{vertices}) and their relationships ({\em edges}). A {\em tree} is a
specific type of graph with exactly one unique path between any two nodes. A
{\em phylogenetic tree} is a tree with verticies representing species, and edges
representing an evolutionary process.  Thus, a phylogenetic tree is a
representation of evolutionary history and relationships.

{\bf TODO: Rework this, avoid the use of *valent}
Generally, phylogenetic trees have an additional constraint: every node is
either {\em trivalent}, i.e. has exactly 3 edges adjacent to it, or {\em
univalent}, i.e. exactly 1 edge adjacent . This is to say, every vertex is a
leaf, sometimes called a tip, or an interior node with exactly 3 adjacent
vertices. The exception to this is a specially designated node called the root.
The root is a {\em bivalent} vertex, i.e. it has two adjacent edges. These
vertices are the children of the root.

In addition to a phylogenetic tree, phylogenetic inference requires a model of
evolution. Commonly, a Markov substution process is used
\cite{yang_computational_2006}, along with sequence data such as DNA sequences.
Using this model of evolution, a probability of one species evolving into
another in a specified amount of time can be calcluated as the probability of
one sequence evolving into another. By representing each edge of the tree as one
of these Markov processes, we can calculate the liklihood of both the
subsutution processes, and the choosen topology of the tree.

Phylogenetic inference often does not seek to find a root. The reasons for this
are many, but a large reason is the increased amount of effort required to
perform analysis. In molecular clock and outgroup rooting, the rooting step is
performed after the initial tree inference. If a nonreversable model is used,
then the pully principle \cite{felsenstein_evolutionary_1981} cannot be used. To
summarize, the pully priniciple shows that on a phylogenetic model with a
reversable markov process, the root placement doesn't affect the final
likelihood of the tree. If a nonreversable model is used, then the root
placement needs to be taken into account. To exhaustivly search for the root, we
must place a root at every possible location, and then optimize model
parameters. If we have $n$ taxa, then doing this addtional work requires on the
order of $2n$ additional steps {\em per tree}.

Instead attempting to find the root for every tree, we can instead infer an
unrooted tree using a reversable model, and then infer the root with a
reversble model, using an exhaustive search. While this is faster, there are
still challenges with optimizing the model parameters
\cite{huelsenbeck_inferring_2002}. Specifically, there are many local optima to
the likelihood function, which makes find maximum likelihood model parameters
difficult.

Root Digger proceeds like so: First, it places a root in a location, and then
calculates its likelihood. Then, in order to optimize the model parameters, we
use that likelihood to perform simulated annealing. Simulated annealing is used
for several purposes. Primarily, it is used to avoid challenges with many
optima, (see \cite{huelsenbeck_inferring_2002}) but it is also used to avoid the
computation of a derivative with respect to the model parameters.

\section{The Software}

In order to implement both phylogenetic inference and non-reverable models, Root
Digger has two major dependancies: GNU Scientific Library (GSL)
\cite{gough_gnu_2009} and the Phylogenetic Likelihood Library (LibPLL)
\cite{flouri_phylogenetic_2015}. GSL is used to assist in the decomposition of
a non-symmetric rate matrix, and LibPLL is used for efficient likelihood
calculation.

Usage of Root Digger is simple. All that is required is a metric tree in newick
format, and an alignment in either phylip or fasta format.  The code,
documentation, experiments scripts, as well as any modifications to existing
library can be found at
github\footnote{\url{https://github.com/computations/root_digger}}.

\section{Experiment and Results}

To validate we ran experiments using the following pipeline:

\begin{enumerate}
\item Generate random tree with ETE3 \cite{huerta-cepas_ete_2016}
\item Generate MSA with indelible \cite{fletcher_indelible:_2009}
\item Run Root Digger
\item Compute comparisons
\begin{enumerate}
  \item Calculate rooted RF distance with ETE3 \cite{robinson_comparison_1981}
  \item Map root placement onto original tree.
\end{enumerate}

\end{enumerate}

Additionally, we repeat the pipeline for a specified number of iterations. We
could vary two parameters: sites and taxa. The results from these experiements
are summarized in table \ref{table:results}. The distance given is the average
distance from the branch with the true root to the infered root location over
512 trials. {\bf TODO: better summary statistic? This isn't a symmetric
distribution, so the mean is biased}.

\begin{table}
\begin{center}
  \include{tables/results}
  \label{table:results}
\end{center}
\end{table}


\begin{figure}
  \includegraphics[width=.9\linewidth]{figs/random_tree_6400_sites.png}
  \caption{Tree displaying the frequency of root mappings onto the true tree.
  Total trials $n=100$.}
  \label{fig:mapped_tree}
\end{figure}

\begin{figure}
  \includegraphics[width=.9\linewidth]{figs/uniform_tree_6400_sites.png}
  \caption{Tree displaying the frequency of root mappings onto the true tree.
    This tree has uniform branch lengths. Total trials $n=100$.}
  \label{fig:mapped_uniform_tree}
\end{figure}

\begin{figure}
  \includegraphics[width=.9\linewidth]{figs/lba_tree2.png}
  \caption{Tree displaying the frequency of root mappings onto the true tree.
  This tree has a long branch leading from a, which is 50 times larger than the
  other two branches. Total trials $n=100$.}
  \label{fig:lba_tree}
\end{figure}

\textbf{TODO?: Time benchmarks}

% Outline:
% - indel data generation
% - run setup (cpu, memory etc)
% - show results (time, accuracy)
%   - Accuracy should be measured by getting the root on the right edge, as well
%   as how far along that edge the root is.

\section{Conclusion}

Placing a root by a non-reversable model is challenging. Traditional
optimization methods have many difficulties finding true optima in a space with
many local optima. Nevertheless, a root can be placed efficiently and accuratly.

We found that with our method, the root was reasonably stable for various
lengths of alignments. This suggests that the placement of a root on a tree can
be done even when large quantities of data are not present.

There are several improvements to the software that can be done. First is
implementing an analytical derivative for the likelihood of a placement of a
root along a given branch.

\bibliographystyle{acm}
\bibliography{main}

\end{document}
