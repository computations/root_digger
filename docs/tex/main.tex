\documentclass{article}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{xcolor}

\title{Root Digger: a root placement program for phylogenetic trees}
\author{Ben Bettisworth, Alexandros Stamatakis}
\date{\today}

\newcommand{\RootDigger}{RootDigger}
\newcommand{\RootDiggertt}{\texttt{RootDigger}}
\newcommand{\BenComment}[1]{{\bf \color{blue} {#1}}}
\newcommand{\AlexisComment}[1]{{\bf \color{green} {#1}}}

\begin{document}
\begin{abstract}
  In phylogenetic analysis, it is common to infer trees which are unrooted. This
  is to say, it is unknown which node is the most recent common ancestor of all
  the taxa present in the phylogenetic tree. This information is often desirable,
  as it provides a direction to the edges in the tree. There exist several
  methods to recover a root, including midpoint rooting and using a special taxon
  as a so called outgroup. Additionally, a non-reversable Markov model can be used
  to compute the likelihood of a root. In this paper, we present software which
  uses a provided non-reversable model to compute the most likely root location.
\end{abstract}

\maketitle

% Main Points:
% - Rerunning analysis with outgroups is expensive, and can introduce errors
% - Midpoint rooting is a joke
% - This is fast and accurate.


\section{Introduction}

% Outline:
% - What is rooting
% - Why do we need it
% - Existing methods
% - What this method is
% - Why should we use this method

When inferring phylogenetic trees, it is common to infer unrooted trees. This
due to a common assumption: reversibility of the character substituion process
\cite{felsenstein_evolutionary_1981}. By making this assumption, the ability to
distinguish a root is lost. A rooting is desirable, though, as it can resolve
long standing disputes regarding the placment of large clades on the tree of
life \cite{dunn_animal_2014}.

There are several methods to root an existing phylogenetic tree, which generally
fall into one of three categories: methods which use additional topological
information not present in the molecular data; methods which utilize some
variation of the molecular clock hypothesis; and methods which use a
non-reversable model.

Methods that use additional topological information take advantage of prior
knowledge about the world, which isn't present in the data that is used to infer
a tree. In particular, knowledge about species which are distantly related can
be used to add an outgroup to phylogenetic analysis. This outgroup can then be
used to place the root on the tree.

There are challenges to adding an outgroup to an analysis. Gatsey et.al.
\cite{gatesy_how_2007} \BenComment{How do I cite papers directly, should I just
  use the number?} showed how adding a single taxa to an analysis can
significantly impact the resulting tree topology, even for the taxa which were
already present in the analysis. Holland \cite{holland_outgroup_2003}
investigates this phenomenon in simulations, and that outgroups effecting the
topology of ingroups can be uncomfortably common.

Alternativly, molecular clock analysis can be used to place a root without prior
topological knowledge\cite{yang_computational_2006}. The molecular clock
hypothesis says that base substitution "ticks" at stochastically constant rate.
Using this assumption, or some variant, a likely root can be placed on the root.

Molecular clock analysis has its own difficulties. In particular, the clock
does not "tick" at a constant rate all over the tree as shown in
\cite{steiper_primate_2006} and \cite{li_molecular_1987}. Relaxed clock models
exist which can help with this problem, but are not always successful as shown
in \cite{battistuzzi_performance_2010}.

The final method that can place a root on a tree is to perform the phylogenetic
analysis using a non-reversable model. By using a non-reversable model, we can
place a direction of time for the branches on a tree
\cite{yap_rooting_2005}. Several software packages are able to infer a
phylogenetic tree under an unreversable model, thereby inferring a root
\cite{nguyen_iq-tree:_2015} \cite{ronquist_mrbayes_2003}. \BenComment{Write a
  bit here about why these existing solutions are slow}

%In phylogenetic analysis, it is common to infer an unrooted tree. This is due to
%several factors, including: speed of analysis
%\cite{felsenstein_evolutionary_1981}, tool support \cite{stamatakis_raxml_2014},
%and availability of other methods \cite{huelsenbeck_inferring_2002}. Instead,
%root placement analysis has generally been performed using additional data, such
%as outgroups, or via a molecular clock hypothesis. 
%
%% reasons outgrouping sucks:
%% - additional computational requirements
%% - selecting an outgroup is error prone
%% - outgroup can effect the topology of the ingroup
%
%Outgrouping is a rooting technique that involves adding additional data beyond
%the taxa in question for the phylogeny. Unfortunately, including an outgroup in
%the dataset introduces both increased computational load, as well as systematic
%errors \cite{gatesy_how_2007} \cite{holland_outgroup_2003}. Particularly
%relevant errors are changes to the ingroup topology when an outgroup is added.

\section{Methods}

Phylogenetic inference requires a model of evolution. Commonly, a Markov
substution process is used \cite{yang_computational_2006}, along with sequence
data such as DNA sequences.  Using this model of evolution, a probability of one
species evolving into another in a specified amount of time can be calculated as
the probability of one sequence evolving into another. By representing each edge
of the tree as one of these Markov processes, we can calculate the likelihood of
both the subsutution processes, and the choosen topology of the tree.

Since it is commonly assumed that the Markovian process is reversible, the tree
that results from this process lacks a root. If we eliminate the reversibility
assumption, then we also loose the benefits of the pulley principle
\cite{felsenstein_evolutionary_1981}. Since the root location effects the
likelihood of the tree, then multiple rootings must be attempted for each tree.
In the worst case, this increases the work {\em per tree} by a factor of
$\mathcal{O}(n)$. While there are methods to reduce the amount of work required,
eliminating the reversibility assumption drastically increases the effort
required to infer a tree.

Instead attempting to find the root for every tree encountered during the tree
search, we can instead infer an unrooted tree using a reversible model, and then
infer the root with a reversible model, using an exhaustive search.
This is faster, as it skips the expensive step of looking for good rootings
during intermediate trees. There are still additional challenges though, as the
likelihood function for rooting on a phylogenetic tree is filled with local
maxima \cite{huelsenbeck_inferring_2002}.

\RootDigger starts by selecting a set of branches at random (with replacement).
The set of random branches will be used as the initial root location for the
next stages of the search. The search then proceeds by setting the initial model
parameters to be uniform, and then:

\begin{enumerate}
  \item Optimize Rates (via BFGS).
  \item Optimize Frequencies (via BFGS).
  \item Find and move to the next best root.
  \item Check stopping criterion:
        \begin{itemize}
          \item Is the current root location the same as the last iteration's root, taking
                into account branch lengths?
          \item Is the distance from the current log likelihood to previous log
                likelihood?
        \end{itemize}
  \item Repeat from 1 for a maximum of 1000 iterations.
\end{enumerate}

Step 3 is performed by first calculating the top 5\% of root locations at the
midpoint by likelihood. We use this top 5\% to conduct a more detailed search
along the branch for the optimal root location. To do this search, we view the
problem as finding the maximum argument for some function $f_i(\alpha)$ which
calculates the likelihood of the tree with a root position $\alpha t_i$ along
the branch $i$, where $0 \leq \alpha \leq 1$. Therefore, we are looking for $i$
and $\alpha$, which will indicate which branch and where on that branch to place
the root.

By viewing the problem in this way, the problem can be solved using more
efficient 1 dimensional optimization techniques, which involve finding the root
of the derivative. In this case, we use Brent's method, due to the lack of
access to a second derivative \footnotemark.

\footnotetext{We could compute a derivative, but the library that we use
  computes logged likelihoods, and we require them unlogged. The effort to rewrite
  the functions that would compute this derivative was deemed to be too much
  relative to the savings. In principle, the computation could be done.}

A limitation of root finding methods is that they will fail to find {\it all} the
roots of a function if there are multiple roots. To compensate, we need to
search for bracketing windows that can be used to safely find roots.
Unfortunately, we are not aware of a general method for finding such bracketing
windows, so a recursive method is employed, were the search range is reduced in
half and searched for appropriate \footnotemark windows.

\footnotetext{Appropriate here means that the sign of the function in question has
  opposite signs at the endpoints of the window.}

\section{The Software}

In order to implement both phylogenetic inference and non-reverable models,
\RootDigger has two major dependancies: GNU Scientific Library (GSL)
\cite{gough_gnu_2009} and the Phylogenetic Likelihood Library (LibPLL)
\cite{flouri_phylogenetic_2015}. GSL is used to assist in the decomposition of a
non-symmetric rate matrix, and LibPLL is used for efficient likelihood
calculation.

Usage of \RootDigger is simple. All that is required is a metric tree in newick
format, and an alignment in either phylip or fasta format. The code,
documentation, experiment scripts, datasets, as well as any modifications to existing
libraries can be found at
github\footnote{\url{https://github.com/computations/root_digger}}.

\section{Experiments and Results}

To validate we ran experiments using the following pipeline:

\begin{enumerate}
  \item Generate a random tree with ETE3 \cite{huerta-cepas_ete_2016} and random
        model parameters.
  \item Simulate an MSA with indelible \cite{fletcher_indelible:_2009}
  \item Run RootDigger and IQ-TREE \cite{nguyen_iq-tree:_2015} on the simulated MSA, given the generated random tree.
  \item Compute comparisons
        \begin{enumerate}
          \item Calculate rooted RF distance with ETE3 \cite{robinson_comparison_1981}
          \item Map root placement onto original tree.
        \end{enumerate}
\end{enumerate}

Additionally, we repeat the pipeline for a specified number of iterations. We
could vary two parameters: sites and taxa. The results from these experiements
are summarized in table \ref{table:results}. The distance given is the average
distance from the branch with the true root to the infered root location over
100 trials. In addition to the simulated pipeline, we validated root digger with
emperical data. The emperical datasets used are listed in
table~\ref{table:datasets}.

\begin{table}
  \begin{center}
    \include{tables/datasets}
    \label{table:datasets}
  \end{center}
\end{table}

\begin{table}
  \begin{center}
    \include{tables/results}
    \label{table:results}
  \end{center}
\end{table}

\BenComment{TODO: Time benchmarks}

\section{Conclusion}

\BenComment{Update this section with the new results}

Placing a root by a non-reversable model is challenging. Traditional
optimization methods have many difficulties finding true optima in a space with
many local optima. Nevertheless, a root can be placed efficiently and accuratly.

We did find evidence of a form of long branch attraction. In figures
?? and ?? we can see examples of this. In these
cases, an interior branch is exceptionally (50x) longer than the rest of the
braches. We claim that while this is concerning, it is also a pathalogical case.
Normally, a taxa with such a long branch length leading to it would be
considered an outgroup.

Other than the pathelogical cases of extremely long branches, we found that
\RootDigger manages to place the root with good accuracy, normally exceeding
60\%, more often falling in the 75\% range. This suggests a good convergence,
where multiple runs of \RootDigger strongly reinforce the true location of the
root.

We found that with our method, the root was reasonably stable for various
lengths of alignments. This suggests that the placement of a root on a tree can
be done even when large quantities of data are not present.

Going forward, there are several improvements to the software that can be done.
First is implementing an analytical derivative for the likelihood of a placement
of a root along a given branch. \RootDigger spends \~ 40\% of its time,
calculating this derivative. While computing the derivative analyticallly
wouldn't eliminate the time spent on calculating derivatives, it will likely
reduce it by at least half.

Secondly, there are feature improvements that could be made. Currently,
\RootDigger only supports single partition models with the UNREST (called 12.12
in IQ-TREE) model. An obvious improvement is to increase the number of models
that are supported, particularly those models which are a part of the Lie Group
\cite{woodhams_new_2015}.

\bibliographystyle{acm}
\bibliography{main}

\end{document}
